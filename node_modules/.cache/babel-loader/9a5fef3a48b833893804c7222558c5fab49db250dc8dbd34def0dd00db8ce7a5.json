{"ast":null,"code":"import { openDB } from 'idb';\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\nclass DatabaseService {\n  constructor() {\n    this.db = null;\n    this.dbName = 'FormBuilderDB';\n    this.version = 2; // Increment version for new store\n    this.init();\n  }\n  async init() {\n    try {\n      this.db = await openDB(this.dbName, this.version, {\n        upgrade: (db, oldVersion, newVersion) => {\n          // Users store\n          if (!db.objectStoreNames.contains('users')) {\n            const userStore = db.createObjectStore('users', {\n              keyPath: 'id'\n            });\n            userStore.createIndex('email', 'email', {\n              unique: true\n            });\n            userStore.createIndex('role', 'role');\n          }\n\n          // Forms store\n          if (!db.objectStoreNames.contains('forms')) {\n            const formStore = db.createObjectStore('forms', {\n              keyPath: 'id'\n            });\n            formStore.createIndex('created_by', 'created_by');\n            formStore.createIndex('is_active', 'is_active');\n          }\n\n          // Form responses store\n          if (!db.objectStoreNames.contains('form_responses')) {\n            const responseStore = db.createObjectStore('form_responses', {\n              keyPath: 'id'\n            });\n            responseStore.createIndex('form_id', 'form_id');\n            responseStore.createIndex('user_id', 'user_id');\n            responseStore.createIndex('form_user', ['form_id', 'user_id'], {\n              unique: true\n            });\n          }\n\n          // Password reset tokens store (new in version 2)\n          if (!db.objectStoreNames.contains('password_reset_tokens')) {\n            const tokenStore = db.createObjectStore('password_reset_tokens', {\n              keyPath: 'id'\n            });\n            tokenStore.createIndex('token', 'token', {\n              unique: true\n            });\n            tokenStore.createIndex('user_id', 'user_id');\n            tokenStore.createIndex('expires_at', 'expires_at');\n          }\n        }\n      });\n      await this.seedInitialData();\n    } catch (error) {\n      console.error('Database initialization error:', error);\n    }\n  }\n  async seedInitialData() {\n    try {\n      // Check if admin user already exists\n      const adminExists = await this.getUserByEmail('admin@example.com');\n      if (!adminExists) {\n        // Create admin user\n        const adminPassword = await bcrypt.hash('admin123', 10);\n        await this.createUser('admin@example.com', adminPassword, 'Admin User', 'admin');\n\n        // Create demo user\n        const userPassword = await bcrypt.hash('user123', 10);\n        await this.createUser('user@example.com', userPassword, 'Regular User', 'user');\n        await this.createUser('user2@example.com', userPassword, 'Another User', 'user');\n        console.log('Initial data seeded successfully');\n      }\n    } catch (error) {\n      console.error('Error seeding initial data:', error);\n    }\n  }\n\n  // User operations\n  async createUser(email, password, name, role = 'user', socialProvider = null, socialId = null) {\n    try {\n      const userId = uuidv4();\n      const user = {\n        id: userId,\n        email,\n        password,\n        name,\n        role,\n        social_provider: socialProvider,\n        social_id: socialId,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      await this.db.add('users', user);\n      return {\n        success: true,\n        userId\n      };\n    } catch (error) {\n      if (error.name === 'ConstraintError') {\n        throw new Error('User already exists');\n      }\n      throw error;\n    }\n  }\n  async authenticateUser(email, password) {\n    try {\n      const user = await this.getUserByEmail(email);\n      if (!user) {\n        return null;\n      }\n      const isValidPassword = await bcrypt.compare(password, user.password);\n      if (!isValidPassword) {\n        return null;\n      }\n      const {\n        password: _,\n        ...userWithoutPassword\n      } = user;\n      return userWithoutPassword;\n    } catch (error) {\n      console.error('Authentication error:', error);\n      return null;\n    }\n  }\n  async getUserByEmail(email) {\n    try {\n      const tx = this.db.transaction('users', 'readonly');\n      const store = tx.objectStore('users');\n      const index = store.index('email');\n      return await index.get(email);\n    } catch (error) {\n      console.error('Get user by email error:', error);\n      return null;\n    }\n  }\n  async getUserBySocialId(provider, socialId) {\n    try {\n      const tx = this.db.transaction('users', 'readonly');\n      const store = tx.objectStore('users');\n      const allUsers = await store.getAll();\n      return allUsers.find(user => user.social_provider === provider && user.social_id === socialId) || null;\n    } catch (error) {\n      console.error('Get user by social ID error:', error);\n      return null;\n    }\n  }\n  async getUserById(userId) {\n    try {\n      return await this.db.get('users', userId);\n    } catch (error) {\n      console.error('Get user error:', error);\n      return null;\n    }\n  }\n  async getAllUsers() {\n    try {\n      return await this.db.getAll('users');\n    } catch (error) {\n      console.error('Get all users error:', error);\n      return [];\n    }\n  }\n\n  // Password reset operations\n  async createPasswordResetToken(email) {\n    try {\n      const user = await this.getUserByEmail(email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      // Generate a secure token\n      const token = uuidv4();\n      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\n\n      const resetToken = {\n        id: uuidv4(),\n        token,\n        user_id: user.id,\n        expires_at: expiresAt.toISOString(),\n        created_at: new Date().toISOString()\n      };\n      await this.db.add('password_reset_tokens', resetToken);\n      return {\n        success: true,\n        token,\n        user\n      };\n    } catch (error) {\n      console.error('Create password reset token error:', error);\n      throw error;\n    }\n  }\n  async validatePasswordResetToken(token) {\n    try {\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\n      const store = tx.objectStore('password_reset_tokens');\n      const index = store.index('token');\n      const resetToken = await index.get(token);\n      if (!resetToken) {\n        return null;\n      }\n\n      // Check if token is expired\n      const expiresAt = new Date(resetToken.expires_at);\n      if (expiresAt < new Date()) {\n        // Delete expired token\n        await this.deletePasswordResetToken(token);\n        return null;\n      }\n      return resetToken;\n    } catch (error) {\n      console.error('Validate password reset token error:', error);\n      return null;\n    }\n  }\n  async resetPassword(token, newPassword) {\n    try {\n      const resetToken = await this.validatePasswordResetToken(token);\n      if (!resetToken) {\n        throw new Error('Invalid or expired token');\n      }\n\n      // Hash the new password\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n      // Update user password\n      const user = await this.getUserById(resetToken.user_id);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      const updatedUser = {\n        ...user,\n        password: hashedPassword,\n        updated_at: new Date().toISOString()\n      };\n      await this.db.put('users', updatedUser);\n\n      // Delete the used token\n      await this.deletePasswordResetToken(token);\n      return {\n        success: true,\n        user: updatedUser\n      };\n    } catch (error) {\n      console.error('Reset password error:', error);\n      throw error;\n    }\n  }\n  async deletePasswordResetToken(token) {\n    try {\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\n      const store = tx.objectStore('password_reset_tokens');\n      const index = store.index('token');\n      const resetToken = await index.get(token);\n      if (resetToken) {\n        await this.db.delete('password_reset_tokens', resetToken.id);\n      }\n    } catch (error) {\n      console.error('Delete password reset token error:', error);\n    }\n  }\n  async cleanupExpiredTokens() {\n    try {\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\n      const store = tx.objectStore('password_reset_tokens');\n      const index = store.index('expires_at');\n      const allTokens = await index.getAll();\n      const now = new Date();\n      const expiredTokens = allTokens.filter(token => new Date(token.expires_at) < now);\n      for (const token of expiredTokens) {\n        await this.db.delete('password_reset_tokens', token.id);\n      }\n      return expiredTokens.length;\n    } catch (error) {\n      console.error('Cleanup expired tokens error:', error);\n      return 0;\n    }\n  }\n\n  // Form operations\n  async createForm(formData, createdBy) {\n    try {\n      const formId = uuidv4();\n      const form = {\n        id: formId,\n        title: formData.title,\n        description: formData.description,\n        fields: formData.fields,\n        is_active: true,\n        created_by: createdBy,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      await this.db.add('forms', form);\n      return {\n        success: true,\n        formId\n      };\n    } catch (error) {\n      console.error('Create form error:', error);\n      throw error;\n    }\n  }\n  async updateForm(formId, formData) {\n    try {\n      const existingForm = await this.db.get('forms', formId);\n      if (!existingForm) {\n        throw new Error('Form not found');\n      }\n      const updatedForm = {\n        ...existingForm,\n        title: formData.title,\n        description: formData.description,\n        fields: formData.fields,\n        updated_at: new Date().toISOString()\n      };\n      await this.db.put('forms', updatedForm);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Update form error:', error);\n      throw error;\n    }\n  }\n  async deleteForm(formId) {\n    try {\n      await this.db.delete('forms', formId);\n      // Also delete all responses for this form\n      const responses = await this.getFormResponses(formId);\n      for (const response of responses) {\n        await this.db.delete('form_responses', response.id);\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Delete form error:', error);\n      throw error;\n    }\n  }\n  async getFormById(formId) {\n    try {\n      return await this.db.get('forms', formId);\n    } catch (error) {\n      console.error('Get form error:', error);\n      return null;\n    }\n  }\n  async getAllForms() {\n    try {\n      return await this.db.getAll('forms');\n    } catch (error) {\n      console.error('Get all forms error:', error);\n      return [];\n    }\n  }\n  async getActiveForms() {\n    try {\n      const tx = this.db.transaction('forms', 'readonly');\n      const store = tx.objectStore('forms');\n      const index = store.index('is_active');\n      return await index.getAll(true);\n    } catch (error) {\n      console.error('Get active forms error:', error);\n      return [];\n    }\n  }\n\n  // Response operations\n  async submitResponse(formId, userId, responseData) {\n    try {\n      const responseId = uuidv4();\n      const response = {\n        id: responseId,\n        form_id: formId,\n        user_id: userId,\n        data: responseData,\n        submitted_at: new Date().toISOString()\n      };\n      await this.db.add('form_responses', response);\n      return {\n        success: true,\n        responseId\n      };\n    } catch (error) {\n      if (error.name === 'ConstraintError') {\n        throw new Error('You have already responded to this form');\n      }\n      console.error('Submit response error:', error);\n      throw error;\n    }\n  }\n  async getFormResponses(formId) {\n    try {\n      const tx = this.db.transaction('form_responses', 'readonly');\n      const store = tx.objectStore('form_responses');\n      const index = store.index('form_id');\n      const responses = await index.getAll(formId);\n\n      // Get user details for each response\n      const responsesWithUserData = await Promise.all(responses.map(async response => {\n        const user = await this.getUserById(response.user_id);\n        return {\n          ...response,\n          user_name: (user === null || user === void 0 ? void 0 : user.name) || `User ${response.user_id}`,\n          user_email: (user === null || user === void 0 ? void 0 : user.email) || ''\n        };\n      }));\n      return responsesWithUserData.sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));\n    } catch (error) {\n      console.error('Get form responses error:', error);\n      return [];\n    }\n  }\n  async getUserResponses(userId) {\n    try {\n      const tx = this.db.transaction('form_responses', 'readonly');\n      const store = tx.objectStore('form_responses');\n      const index = store.index('user_id');\n      const responses = await index.getAll(userId);\n\n      // Get form details for each response\n      const responsesWithFormData = await Promise.all(responses.map(async response => {\n        const form = await this.getFormById(response.form_id);\n        return {\n          ...response,\n          form_title: (form === null || form === void 0 ? void 0 : form.title) || 'Unknown Form'\n        };\n      }));\n      return responsesWithFormData.sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));\n    } catch (error) {\n      console.error('Get user responses error:', error);\n      return [];\n    }\n  }\n  async hasUserResponded(formId, userId) {\n    try {\n      const tx = this.db.transaction('form_responses', 'readonly');\n      const store = tx.objectStore('form_responses');\n      const index = store.index('form_user');\n      const response = await index.get([formId, userId]);\n      return !!response;\n    } catch (error) {\n      console.error('Check user response error:', error);\n      return false;\n    }\n  }\n  async getFormResponseCount(formId) {\n    try {\n      const tx = this.db.transaction('form_responses', 'readonly');\n      const store = tx.objectStore('form_responses');\n      const index = store.index('form_id');\n      const responses = await index.getAll(formId);\n      return responses.length;\n    } catch (error) {\n      console.error('Get response count error:', error);\n      return 0;\n    }\n  }\n\n  // Statistics\n  async getStatistics() {\n    try {\n      const [users, forms, responses] = await Promise.all([this.getAllUsers(), this.getAllForms(), this.db.getAll('form_responses')]);\n      const activeForms = forms.filter(form => form.is_active);\n      return {\n        totalUsers: users.length,\n        totalForms: forms.length,\n        totalResponses: responses.length,\n        activeForms: activeForms.length\n      };\n    } catch (error) {\n      console.error('Get statistics error:', error);\n      return {\n        totalUsers: 0,\n        totalForms: 0,\n        totalResponses: 0,\n        activeForms: 0\n      };\n    }\n  }\n\n  // Close database connection\n  close() {\n    if (this.db) {\n      this.db.close();\n    }\n  }\n}\n\n// Create a singleton instance\nconst databaseService = new DatabaseService();\nexport default databaseService;","map":{"version":3,"names":["openDB","v4","uuidv4","bcrypt","DatabaseService","constructor","db","dbName","version","init","upgrade","oldVersion","newVersion","objectStoreNames","contains","userStore","createObjectStore","keyPath","createIndex","unique","formStore","responseStore","tokenStore","seedInitialData","error","console","adminExists","getUserByEmail","adminPassword","hash","createUser","userPassword","log","email","password","name","role","socialProvider","socialId","userId","user","id","social_provider","social_id","created_at","Date","toISOString","updated_at","add","success","Error","authenticateUser","isValidPassword","compare","_","userWithoutPassword","tx","transaction","store","objectStore","index","get","getUserBySocialId","provider","allUsers","getAll","find","getUserById","getAllUsers","createPasswordResetToken","token","expiresAt","now","resetToken","user_id","expires_at","validatePasswordResetToken","deletePasswordResetToken","resetPassword","newPassword","hashedPassword","updatedUser","put","delete","cleanupExpiredTokens","allTokens","expiredTokens","filter","length","createForm","formData","createdBy","formId","form","title","description","fields","is_active","created_by","updateForm","existingForm","updatedForm","deleteForm","responses","getFormResponses","response","getFormById","getAllForms","getActiveForms","submitResponse","responseData","responseId","form_id","data","submitted_at","responsesWithUserData","Promise","all","map","user_name","user_email","sort","a","b","getUserResponses","responsesWithFormData","form_title","hasUserResponded","getFormResponseCount","getStatistics","users","forms","activeForms","totalUsers","totalForms","totalResponses","close","databaseService"],"sources":["C:/Users/Highcastle/Documents/Cidadão+ Consulta Pública/src/services/database.js"],"sourcesContent":["import { openDB } from 'idb';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nclass DatabaseService {\r\n  constructor() {\r\n    this.db = null;\r\n    this.dbName = 'FormBuilderDB';\r\n    this.version = 2; // Increment version for new store\r\n    this.init();\r\n  }\r\n\r\n  async init() {\r\n    try {\r\n      this.db = await openDB(this.dbName, this.version, {\r\n        upgrade: (db, oldVersion, newVersion) => {\r\n          // Users store\r\n          if (!db.objectStoreNames.contains('users')) {\r\n            const userStore = db.createObjectStore('users', { keyPath: 'id' });\r\n            userStore.createIndex('email', 'email', { unique: true });\r\n            userStore.createIndex('role', 'role');\r\n          }\r\n\r\n          // Forms store\r\n          if (!db.objectStoreNames.contains('forms')) {\r\n            const formStore = db.createObjectStore('forms', { keyPath: 'id' });\r\n            formStore.createIndex('created_by', 'created_by');\r\n            formStore.createIndex('is_active', 'is_active');\r\n          }\r\n\r\n          // Form responses store\r\n          if (!db.objectStoreNames.contains('form_responses')) {\r\n            const responseStore = db.createObjectStore('form_responses', { keyPath: 'id' });\r\n            responseStore.createIndex('form_id', 'form_id');\r\n            responseStore.createIndex('user_id', 'user_id');\r\n            responseStore.createIndex('form_user', ['form_id', 'user_id'], { unique: true });\r\n          }\r\n\r\n          // Password reset tokens store (new in version 2)\r\n          if (!db.objectStoreNames.contains('password_reset_tokens')) {\r\n            const tokenStore = db.createObjectStore('password_reset_tokens', { keyPath: 'id' });\r\n            tokenStore.createIndex('token', 'token', { unique: true });\r\n            tokenStore.createIndex('user_id', 'user_id');\r\n            tokenStore.createIndex('expires_at', 'expires_at');\r\n          }\r\n        }\r\n      });\r\n\r\n      await this.seedInitialData();\r\n    } catch (error) {\r\n      console.error('Database initialization error:', error);\r\n    }\r\n  }\r\n\r\n  async seedInitialData() {\r\n    try {\r\n      // Check if admin user already exists\r\n      const adminExists = await this.getUserByEmail('admin@example.com');\r\n      \r\n      if (!adminExists) {\r\n        // Create admin user\r\n        const adminPassword = await bcrypt.hash('admin123', 10);\r\n        await this.createUser('admin@example.com', adminPassword, 'Admin User', 'admin');\r\n\r\n        // Create demo user\r\n        const userPassword = await bcrypt.hash('user123', 10);\r\n        await this.createUser('user@example.com', userPassword, 'Regular User', 'user');\r\n        await this.createUser('user2@example.com', userPassword, 'Another User', 'user');\r\n\r\n        console.log('Initial data seeded successfully');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error seeding initial data:', error);\r\n    }\r\n  }\r\n\r\n  // User operations\r\n  async createUser(email, password, name, role = 'user', socialProvider = null, socialId = null) {\r\n    try {\r\n      const userId = uuidv4();\r\n      const user = {\r\n        id: userId,\r\n        email,\r\n        password,\r\n        name,\r\n        role,\r\n        social_provider: socialProvider,\r\n        social_id: socialId,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.add('users', user);\r\n      return { success: true, userId };\r\n    } catch (error) {\r\n      if (error.name === 'ConstraintError') {\r\n        throw new Error('User already exists');\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async authenticateUser(email, password) {\r\n    try {\r\n      const user = await this.getUserByEmail(email);\r\n      \r\n      if (!user) {\r\n        return null;\r\n      }\r\n\r\n      const isValidPassword = await bcrypt.compare(password, user.password);\r\n      \r\n      if (!isValidPassword) {\r\n        return null;\r\n      }\r\n\r\n      const { password: _, ...userWithoutPassword } = user;\r\n      return userWithoutPassword;\r\n    } catch (error) {\r\n      console.error('Authentication error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getUserByEmail(email) {\r\n    try {\r\n      const tx = this.db.transaction('users', 'readonly');\r\n      const store = tx.objectStore('users');\r\n      const index = store.index('email');\r\n      return await index.get(email);\r\n    } catch (error) {\r\n      console.error('Get user by email error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getUserBySocialId(provider, socialId) {\r\n    try {\r\n      const tx = this.db.transaction('users', 'readonly');\r\n      const store = tx.objectStore('users');\r\n      const allUsers = await store.getAll();\r\n      return allUsers.find(user => \r\n        user.social_provider === provider && user.social_id === socialId\r\n      ) || null;\r\n    } catch (error) {\r\n      console.error('Get user by social ID error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getUserById(userId) {\r\n    try {\r\n      return await this.db.get('users', userId);\r\n    } catch (error) {\r\n      console.error('Get user error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getAllUsers() {\r\n    try {\r\n      return await this.db.getAll('users');\r\n    } catch (error) {\r\n      console.error('Get all users error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Password reset operations\r\n  async createPasswordResetToken(email) {\r\n    try {\r\n      const user = await this.getUserByEmail(email);\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      // Generate a secure token\r\n      const token = uuidv4();\r\n      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n\r\n      const resetToken = {\r\n        id: uuidv4(),\r\n        token,\r\n        user_id: user.id,\r\n        expires_at: expiresAt.toISOString(),\r\n        created_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.add('password_reset_tokens', resetToken);\r\n      return { success: true, token, user };\r\n    } catch (error) {\r\n      console.error('Create password reset token error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async validatePasswordResetToken(token) {\r\n    try {\r\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\r\n      const store = tx.objectStore('password_reset_tokens');\r\n      const index = store.index('token');\r\n      const resetToken = await index.get(token);\r\n\r\n      if (!resetToken) {\r\n        return null;\r\n      }\r\n\r\n      // Check if token is expired\r\n      const expiresAt = new Date(resetToken.expires_at);\r\n      if (expiresAt < new Date()) {\r\n        // Delete expired token\r\n        await this.deletePasswordResetToken(token);\r\n        return null;\r\n      }\r\n\r\n      return resetToken;\r\n    } catch (error) {\r\n      console.error('Validate password reset token error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async resetPassword(token, newPassword) {\r\n    try {\r\n      const resetToken = await this.validatePasswordResetToken(token);\r\n      if (!resetToken) {\r\n        throw new Error('Invalid or expired token');\r\n      }\r\n\r\n      // Hash the new password\r\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n      // Update user password\r\n      const user = await this.getUserById(resetToken.user_id);\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      const updatedUser = {\r\n        ...user,\r\n        password: hashedPassword,\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.put('users', updatedUser);\r\n\r\n      // Delete the used token\r\n      await this.deletePasswordResetToken(token);\r\n\r\n      return { success: true, user: updatedUser };\r\n    } catch (error) {\r\n      console.error('Reset password error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deletePasswordResetToken(token) {\r\n    try {\r\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\r\n      const store = tx.objectStore('password_reset_tokens');\r\n      const index = store.index('token');\r\n      const resetToken = await index.get(token);\r\n\r\n      if (resetToken) {\r\n        await this.db.delete('password_reset_tokens', resetToken.id);\r\n      }\r\n    } catch (error) {\r\n      console.error('Delete password reset token error:', error);\r\n    }\r\n  }\r\n\r\n  async cleanupExpiredTokens() {\r\n    try {\r\n      const tx = this.db.transaction('password_reset_tokens', 'readonly');\r\n      const store = tx.objectStore('password_reset_tokens');\r\n      const index = store.index('expires_at');\r\n      const allTokens = await index.getAll();\r\n\r\n      const now = new Date();\r\n      const expiredTokens = allTokens.filter(token => new Date(token.expires_at) < now);\r\n\r\n      for (const token of expiredTokens) {\r\n        await this.db.delete('password_reset_tokens', token.id);\r\n      }\r\n\r\n      return expiredTokens.length;\r\n    } catch (error) {\r\n      console.error('Cleanup expired tokens error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Form operations\r\n  async createForm(formData, createdBy) {\r\n    try {\r\n      const formId = uuidv4();\r\n      const form = {\r\n        id: formId,\r\n        title: formData.title,\r\n        description: formData.description,\r\n        fields: formData.fields,\r\n        is_active: true,\r\n        created_by: createdBy,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.add('forms', form);\r\n      return { success: true, formId };\r\n    } catch (error) {\r\n      console.error('Create form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateForm(formId, formData) {\r\n    try {\r\n      const existingForm = await this.db.get('forms', formId);\r\n      if (!existingForm) {\r\n        throw new Error('Form not found');\r\n      }\r\n\r\n      const updatedForm = {\r\n        ...existingForm,\r\n        title: formData.title,\r\n        description: formData.description,\r\n        fields: formData.fields,\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.put('forms', updatedForm);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Update form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteForm(formId) {\r\n    try {\r\n      await this.db.delete('forms', formId);\r\n      // Also delete all responses for this form\r\n      const responses = await this.getFormResponses(formId);\r\n      for (const response of responses) {\r\n        await this.db.delete('form_responses', response.id);\r\n      }\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Delete form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getFormById(formId) {\r\n    try {\r\n      return await this.db.get('forms', formId);\r\n    } catch (error) {\r\n      console.error('Get form error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getAllForms() {\r\n    try {\r\n      return await this.db.getAll('forms');\r\n    } catch (error) {\r\n      console.error('Get all forms error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getActiveForms() {\r\n    try {\r\n      const tx = this.db.transaction('forms', 'readonly');\r\n      const store = tx.objectStore('forms');\r\n      const index = store.index('is_active');\r\n      return await index.getAll(true);\r\n    } catch (error) {\r\n      console.error('Get active forms error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Response operations\r\n  async submitResponse(formId, userId, responseData) {\r\n    try {\r\n      const responseId = uuidv4();\r\n      const response = {\r\n        id: responseId,\r\n        form_id: formId,\r\n        user_id: userId,\r\n        data: responseData,\r\n        submitted_at: new Date().toISOString()\r\n      };\r\n\r\n      await this.db.add('form_responses', response);\r\n      return { success: true, responseId };\r\n    } catch (error) {\r\n      if (error.name === 'ConstraintError') {\r\n        throw new Error('You have already responded to this form');\r\n      }\r\n      console.error('Submit response error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getFormResponses(formId) {\r\n    try {\r\n      const tx = this.db.transaction('form_responses', 'readonly');\r\n      const store = tx.objectStore('form_responses');\r\n      const index = store.index('form_id');\r\n      const responses = await index.getAll(formId);\r\n\r\n      // Get user details for each response\r\n      const responsesWithUserData = await Promise.all(\r\n        responses.map(async (response) => {\r\n          const user = await this.getUserById(response.user_id);\r\n          return {\r\n            ...response,\r\n            user_name: user?.name || `User ${response.user_id}`,\r\n            user_email: user?.email || ''\r\n          };\r\n        })\r\n      );\r\n\r\n      return responsesWithUserData.sort((a, b) => \r\n        new Date(b.submitted_at) - new Date(a.submitted_at)\r\n      );\r\n    } catch (error) {\r\n      console.error('Get form responses error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getUserResponses(userId) {\r\n    try {\r\n      const tx = this.db.transaction('form_responses', 'readonly');\r\n      const store = tx.objectStore('form_responses');\r\n      const index = store.index('user_id');\r\n      const responses = await index.getAll(userId);\r\n\r\n      // Get form details for each response\r\n      const responsesWithFormData = await Promise.all(\r\n        responses.map(async (response) => {\r\n          const form = await this.getFormById(response.form_id);\r\n          return {\r\n            ...response,\r\n            form_title: form?.title || 'Unknown Form'\r\n          };\r\n        })\r\n      );\r\n\r\n      return responsesWithFormData.sort((a, b) => \r\n        new Date(b.submitted_at) - new Date(a.submitted_at)\r\n      );\r\n    } catch (error) {\r\n      console.error('Get user responses error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async hasUserResponded(formId, userId) {\r\n    try {\r\n      const tx = this.db.transaction('form_responses', 'readonly');\r\n      const store = tx.objectStore('form_responses');\r\n      const index = store.index('form_user');\r\n      const response = await index.get([formId, userId]);\r\n      return !!response;\r\n    } catch (error) {\r\n      console.error('Check user response error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getFormResponseCount(formId) {\r\n    try {\r\n      const tx = this.db.transaction('form_responses', 'readonly');\r\n      const store = tx.objectStore('form_responses');\r\n      const index = store.index('form_id');\r\n      const responses = await index.getAll(formId);\r\n      return responses.length;\r\n    } catch (error) {\r\n      console.error('Get response count error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Statistics\r\n  async getStatistics() {\r\n    try {\r\n      const [users, forms, responses] = await Promise.all([\r\n        this.getAllUsers(),\r\n        this.getAllForms(),\r\n        this.db.getAll('form_responses')\r\n      ]);\r\n\r\n      const activeForms = forms.filter(form => form.is_active);\r\n\r\n      return {\r\n        totalUsers: users.length,\r\n        totalForms: forms.length,\r\n        totalResponses: responses.length,\r\n        activeForms: activeForms.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Get statistics error:', error);\r\n      return { totalUsers: 0, totalForms: 0, totalResponses: 0, activeForms: 0 };\r\n    }\r\n  }\r\n\r\n  // Close database connection\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n    }\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nconst databaseService = new DatabaseService();\r\n\r\nexport default databaseService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}