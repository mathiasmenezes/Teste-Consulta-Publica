{"ast":null,"code":"'use strict';\n\nconst {\n  cppdb\n} = require('../util');\nconst controllers = new WeakMap();\nmodule.exports = function transaction(fn) {\n  if (typeof fn !== 'function') throw new TypeError('Expected first argument to be a function');\n  const db = this[cppdb];\n  const controller = getController(db, this);\n  const {\n    apply\n  } = Function.prototype;\n\n  // Each version of the transaction function has these same properties\n  const properties = {\n    default: {\n      value: wrapTransaction(apply, fn, db, controller.default)\n    },\n    deferred: {\n      value: wrapTransaction(apply, fn, db, controller.deferred)\n    },\n    immediate: {\n      value: wrapTransaction(apply, fn, db, controller.immediate)\n    },\n    exclusive: {\n      value: wrapTransaction(apply, fn, db, controller.exclusive)\n    },\n    database: {\n      value: this,\n      enumerable: true\n    }\n  };\n  Object.defineProperties(properties.default.value, properties);\n  Object.defineProperties(properties.deferred.value, properties);\n  Object.defineProperties(properties.immediate.value, properties);\n  Object.defineProperties(properties.exclusive.value, properties);\n\n  // Return the default version of the transaction function\n  return properties.default.value;\n};\n\n// Return the database's cached transaction controller, or create a new one\nconst getController = (db, self) => {\n  let controller = controllers.get(db);\n  if (!controller) {\n    const shared = {\n      commit: db.prepare('COMMIT', self, false),\n      rollback: db.prepare('ROLLBACK', self, false),\n      savepoint: db.prepare('SAVEPOINT `\\t_bs3.\\t`', self, false),\n      release: db.prepare('RELEASE `\\t_bs3.\\t`', self, false),\n      rollbackTo: db.prepare('ROLLBACK TO `\\t_bs3.\\t`', self, false)\n    };\n    controllers.set(db, controller = {\n      default: Object.assign({\n        begin: db.prepare('BEGIN', self, false)\n      }, shared),\n      deferred: Object.assign({\n        begin: db.prepare('BEGIN DEFERRED', self, false)\n      }, shared),\n      immediate: Object.assign({\n        begin: db.prepare('BEGIN IMMEDIATE', self, false)\n      }, shared),\n      exclusive: Object.assign({\n        begin: db.prepare('BEGIN EXCLUSIVE', self, false)\n      }, shared)\n    });\n  }\n  return controller;\n};\n\n// Return a new transaction function by wrapping the given function\nconst wrapTransaction = (apply, fn, db, {\n  begin,\n  commit,\n  rollback,\n  savepoint,\n  release,\n  rollbackTo\n}) => function sqliteTransaction() {\n  let before, after, undo;\n  if (db.inTransaction) {\n    before = savepoint;\n    after = release;\n    undo = rollbackTo;\n  } else {\n    before = begin;\n    after = commit;\n    undo = rollback;\n  }\n  before.run();\n  try {\n    const result = apply.call(fn, this, arguments);\n    if (result && typeof result.then === 'function') {\n      throw new TypeError('Transaction function cannot return a promise');\n    }\n    after.run();\n    return result;\n  } catch (ex) {\n    if (db.inTransaction) {\n      undo.run();\n      if (undo !== rollback) after.run();\n    }\n    throw ex;\n  }\n};","map":{"version":3,"names":["cppdb","require","controllers","WeakMap","module","exports","transaction","fn","TypeError","db","controller","getController","apply","Function","prototype","properties","default","value","wrapTransaction","deferred","immediate","exclusive","database","enumerable","Object","defineProperties","self","get","shared","commit","prepare","rollback","savepoint","release","rollbackTo","set","assign","begin","sqliteTransaction","before","after","undo","inTransaction","run","result","call","arguments","then","ex"],"sources":["C:/Users/Highcastle/Documents/Cidadão+ Consulta Pública/node_modules/better-sqlite3/lib/methods/transaction.js"],"sourcesContent":["'use strict';\nconst { cppdb } = require('../util');\nconst controllers = new WeakMap();\n\nmodule.exports = function transaction(fn) {\n\tif (typeof fn !== 'function') throw new TypeError('Expected first argument to be a function');\n\n\tconst db = this[cppdb];\n\tconst controller = getController(db, this);\n\tconst { apply } = Function.prototype;\n\n\t// Each version of the transaction function has these same properties\n\tconst properties = {\n\t\tdefault: { value: wrapTransaction(apply, fn, db, controller.default) },\n\t\tdeferred: { value: wrapTransaction(apply, fn, db, controller.deferred) },\n\t\timmediate: { value: wrapTransaction(apply, fn, db, controller.immediate) },\n\t\texclusive: { value: wrapTransaction(apply, fn, db, controller.exclusive) },\n\t\tdatabase: { value: this, enumerable: true },\n\t};\n\n\tObject.defineProperties(properties.default.value, properties);\n\tObject.defineProperties(properties.deferred.value, properties);\n\tObject.defineProperties(properties.immediate.value, properties);\n\tObject.defineProperties(properties.exclusive.value, properties);\n\n\t// Return the default version of the transaction function\n\treturn properties.default.value;\n};\n\n// Return the database's cached transaction controller, or create a new one\nconst getController = (db, self) => {\n\tlet controller = controllers.get(db);\n\tif (!controller) {\n\t\tconst shared = {\n\t\t\tcommit: db.prepare('COMMIT', self, false),\n\t\t\trollback: db.prepare('ROLLBACK', self, false),\n\t\t\tsavepoint: db.prepare('SAVEPOINT `\\t_bs3.\\t`', self, false),\n\t\t\trelease: db.prepare('RELEASE `\\t_bs3.\\t`', self, false),\n\t\t\trollbackTo: db.prepare('ROLLBACK TO `\\t_bs3.\\t`', self, false),\n\t\t};\n\t\tcontrollers.set(db, controller = {\n\t\t\tdefault: Object.assign({ begin: db.prepare('BEGIN', self, false) }, shared),\n\t\t\tdeferred: Object.assign({ begin: db.prepare('BEGIN DEFERRED', self, false) }, shared),\n\t\t\timmediate: Object.assign({ begin: db.prepare('BEGIN IMMEDIATE', self, false) }, shared),\n\t\t\texclusive: Object.assign({ begin: db.prepare('BEGIN EXCLUSIVE', self, false) }, shared),\n\t\t});\n\t}\n\treturn controller;\n};\n\n// Return a new transaction function by wrapping the given function\nconst wrapTransaction = (apply, fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction() {\n\tlet before, after, undo;\n\tif (db.inTransaction) {\n\t\tbefore = savepoint;\n\t\tafter = release;\n\t\tundo = rollbackTo;\n\t} else {\n\t\tbefore = begin;\n\t\tafter = commit;\n\t\tundo = rollback;\n\t}\n\tbefore.run();\n\ttry {\n\t\tconst result = apply.call(fn, this, arguments);\n\t\tif (result && typeof result.then === 'function') {\n\t\t\tthrow new TypeError('Transaction function cannot return a promise');\n\t\t}\n\t\tafter.run();\n\t\treturn result;\n\t} catch (ex) {\n\t\tif (db.inTransaction) {\n\t\t\tundo.run();\n\t\t\tif (undo !== rollback) after.run();\n\t\t}\n\t\tthrow ex;\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}