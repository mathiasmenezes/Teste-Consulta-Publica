{"ast":null,"code":"import Database from 'better-sqlite3';\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\nclass DatabaseService {\n  constructor() {\n    this.db = null;\n    this.init();\n  }\n  init() {\n    try {\n      this.db = new Database('form-builder.db');\n      this.createTables();\n      this.seedInitialData();\n    } catch (error) {\n      console.error('Database initialization error:', error);\n    }\n  }\n  createTables() {\n    // Users table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password TEXT NOT NULL,\n        name TEXT NOT NULL,\n        role TEXT NOT NULL CHECK (role IN ('admin', 'user')),\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Forms table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS forms (\n        id TEXT PRIMARY KEY,\n        title TEXT NOT NULL,\n        description TEXT,\n        fields TEXT NOT NULL,\n        is_active BOOLEAN DEFAULT 1,\n        created_by TEXT NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (created_by) REFERENCES users (id)\n      )\n    `);\n\n    // Form responses table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS form_responses (\n        id TEXT PRIMARY KEY,\n        form_id TEXT NOT NULL,\n        user_id TEXT NOT NULL,\n        data TEXT NOT NULL,\n        submitted_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (form_id) REFERENCES forms (id) ON DELETE CASCADE,\n        FOREIGN KEY (user_id) REFERENCES users (id),\n        UNIQUE(form_id, user_id)\n      )\n    `);\n\n    // Create indexes for better performance\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_forms_created_by ON forms(created_by);\n      CREATE INDEX IF NOT EXISTS idx_responses_form_id ON form_responses(form_id);\n      CREATE INDEX IF NOT EXISTS idx_responses_user_id ON form_responses(user_id);\n    `);\n  }\n  async seedInitialData() {\n    try {\n      // Check if admin user already exists\n      const adminExists = this.db.prepare('SELECT id FROM users WHERE email = ?').get('admin@example.com');\n      if (!adminExists) {\n        // Create admin user\n        const adminPassword = await bcrypt.hash('admin123', 10);\n        this.db.prepare(`\n          INSERT INTO users (id, email, password, name, role)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(uuidv4(), 'admin@example.com', adminPassword, 'Admin User', 'admin');\n\n        // Create demo user\n        const userPassword = await bcrypt.hash('user123', 10);\n        this.db.prepare(`\n          INSERT INTO users (id, email, password, name, role)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(uuidv4(), 'user@example.com', userPassword, 'Regular User', 'user');\n\n        // Create another demo user\n        this.db.prepare(`\n          INSERT INTO users (id, email, password, name, role)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(uuidv4(), 'user2@example.com', userPassword, 'Another User', 'user');\n        console.log('Initial data seeded successfully');\n      }\n    } catch (error) {\n      console.error('Error seeding initial data:', error);\n    }\n  }\n\n  // User operations\n  async createUser(email, password, name, role = 'user') {\n    try {\n      const hashedPassword = await bcrypt.hash(password, 10);\n      const userId = uuidv4();\n      this.db.prepare(`\n        INSERT INTO users (id, email, password, name, role)\n        VALUES (?, ?, ?, ?, ?)\n      `).run(userId, email, hashedPassword, name, role);\n      return {\n        success: true,\n        userId\n      };\n    } catch (error) {\n      if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n        throw new Error('User already exists');\n      }\n      throw error;\n    }\n  }\n  async authenticateUser(email, password) {\n    try {\n      const user = this.db.prepare('SELECT * FROM users WHERE email = ?').get(email);\n      if (!user) {\n        return null;\n      }\n      const isValidPassword = await bcrypt.compare(password, user.password);\n      if (!isValidPassword) {\n        return null;\n      }\n      const {\n        password: _,\n        ...userWithoutPassword\n      } = user;\n      return userWithoutPassword;\n    } catch (error) {\n      console.error('Authentication error:', error);\n      return null;\n    }\n  }\n  async getUserById(userId) {\n    try {\n      const user = this.db.prepare('SELECT id, email, name, role, created_at FROM users WHERE id = ?').get(userId);\n      return user || null;\n    } catch (error) {\n      console.error('Get user error:', error);\n      return null;\n    }\n  }\n  async getAllUsers() {\n    try {\n      return this.db.prepare('SELECT id, email, name, role, created_at FROM users ORDER BY created_at DESC').all();\n    } catch (error) {\n      console.error('Get all users error:', error);\n      return [];\n    }\n  }\n\n  // Form operations\n  async createForm(formData, createdBy) {\n    try {\n      const formId = uuidv4();\n      const fieldsJson = JSON.stringify(formData.fields);\n      this.db.prepare(`\n        INSERT INTO forms (id, title, description, fields, created_by)\n        VALUES (?, ?, ?, ?, ?)\n      `).run(formId, formData.title, formData.description, fieldsJson, createdBy);\n      return {\n        success: true,\n        formId\n      };\n    } catch (error) {\n      console.error('Create form error:', error);\n      throw error;\n    }\n  }\n  async updateForm(formId, formData) {\n    try {\n      const fieldsJson = JSON.stringify(formData.fields);\n      this.db.prepare(`\n        UPDATE forms \n        SET title = ?, description = ?, fields = ?, updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `).run(formData.title, formData.description, fieldsJson, formId);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Update form error:', error);\n      throw error;\n    }\n  }\n  async deleteForm(formId) {\n    try {\n      this.db.prepare('DELETE FROM forms WHERE id = ?').run(formId);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Delete form error:', error);\n      throw error;\n    }\n  }\n  async getFormById(formId) {\n    try {\n      const form = this.db.prepare('SELECT * FROM forms WHERE id = ?').get(formId);\n      if (form) {\n        return {\n          ...form,\n          fields: JSON.parse(form.fields)\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Get form error:', error);\n      return null;\n    }\n  }\n  async getAllForms() {\n    try {\n      const forms = this.db.prepare('SELECT * FROM forms ORDER BY created_at DESC').all();\n      return forms.map(form => ({\n        ...form,\n        fields: JSON.parse(form.fields)\n      }));\n    } catch (error) {\n      console.error('Get all forms error:', error);\n      return [];\n    }\n  }\n  async getActiveForms() {\n    try {\n      const forms = this.db.prepare('SELECT * FROM forms WHERE is_active = 1 ORDER BY created_at DESC').all();\n      return forms.map(form => ({\n        ...form,\n        fields: JSON.parse(form.fields)\n      }));\n    } catch (error) {\n      console.error('Get active forms error:', error);\n      return [];\n    }\n  }\n\n  // Response operations\n  async submitResponse(formId, userId, responseData) {\n    try {\n      const responseId = uuidv4();\n      const dataJson = JSON.stringify(responseData);\n      this.db.prepare(`\n        INSERT INTO form_responses (id, form_id, user_id, data)\n        VALUES (?, ?, ?, ?)\n      `).run(responseId, formId, userId, dataJson);\n      return {\n        success: true,\n        responseId\n      };\n    } catch (error) {\n      if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n        throw new Error('You have already responded to this form');\n      }\n      console.error('Submit response error:', error);\n      throw error;\n    }\n  }\n  async getFormResponses(formId) {\n    try {\n      const responses = this.db.prepare(`\n        SELECT fr.*, u.name as user_name, u.email as user_email\n        FROM form_responses fr\n        JOIN users u ON fr.user_id = u.id\n        WHERE fr.form_id = ?\n        ORDER BY fr.submitted_at DESC\n      `).all(formId);\n      return responses.map(response => ({\n        ...response,\n        data: JSON.parse(response.data)\n      }));\n    } catch (error) {\n      console.error('Get form responses error:', error);\n      return [];\n    }\n  }\n  async getUserResponses(userId) {\n    try {\n      const responses = this.db.prepare(`\n        SELECT fr.*, f.title as form_title\n        FROM form_responses fr\n        JOIN forms f ON fr.form_id = f.id\n        WHERE fr.user_id = ?\n        ORDER BY fr.submitted_at DESC\n      `).all(userId);\n      return responses.map(response => ({\n        ...response,\n        data: JSON.parse(response.data)\n      }));\n    } catch (error) {\n      console.error('Get user responses error:', error);\n      return [];\n    }\n  }\n  async hasUserResponded(formId, userId) {\n    try {\n      const response = this.db.prepare(`\n        SELECT id FROM form_responses \n        WHERE form_id = ? AND user_id = ?\n      `).get(formId, userId);\n      return !!response;\n    } catch (error) {\n      console.error('Check user response error:', error);\n      return false;\n    }\n  }\n  async getFormResponseCount(formId) {\n    try {\n      const result = this.db.prepare(`\n        SELECT COUNT(*) as count \n        FROM form_responses \n        WHERE form_id = ?\n      `).get(formId);\n      return result.count;\n    } catch (error) {\n      console.error('Get response count error:', error);\n      return 0;\n    }\n  }\n\n  // Statistics\n  async getStatistics() {\n    try {\n      const stats = {\n        totalUsers: this.db.prepare('SELECT COUNT(*) as count FROM users').get().count,\n        totalForms: this.db.prepare('SELECT COUNT(*) as count FROM forms').get().count,\n        totalResponses: this.db.prepare('SELECT COUNT(*) as count FROM form_responses').get().count,\n        activeForms: this.db.prepare('SELECT COUNT(*) as count FROM forms WHERE is_active = 1').get().count\n      };\n      return stats;\n    } catch (error) {\n      console.error('Get statistics error:', error);\n      return {\n        totalUsers: 0,\n        totalForms: 0,\n        totalResponses: 0,\n        activeForms: 0\n      };\n    }\n  }\n\n  // Close database connection\n  close() {\n    if (this.db) {\n      this.db.close();\n    }\n  }\n}\n\n// Create a singleton instance\nconst databaseService = new DatabaseService();\nexport default databaseService;","map":{"version":3,"names":["Database","v4","uuidv4","bcrypt","DatabaseService","constructor","db","init","createTables","seedInitialData","error","console","exec","adminExists","prepare","get","adminPassword","hash","run","userPassword","log","createUser","email","password","name","role","hashedPassword","userId","success","code","Error","authenticateUser","user","isValidPassword","compare","_","userWithoutPassword","getUserById","getAllUsers","all","createForm","formData","createdBy","formId","fieldsJson","JSON","stringify","fields","title","description","updateForm","deleteForm","getFormById","form","parse","getAllForms","forms","map","getActiveForms","submitResponse","responseData","responseId","dataJson","getFormResponses","responses","response","data","getUserResponses","hasUserResponded","getFormResponseCount","result","count","getStatistics","stats","totalUsers","totalForms","totalResponses","activeForms","close","databaseService"],"sources":["C:/Users/Highcastle/Documents/Cidadão+ Consulta Pública/src/services/database.js"],"sourcesContent":["import Database from 'better-sqlite3';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nclass DatabaseService {\r\n  constructor() {\r\n    this.db = null;\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    try {\r\n      this.db = new Database('form-builder.db');\r\n      this.createTables();\r\n      this.seedInitialData();\r\n    } catch (error) {\r\n      console.error('Database initialization error:', error);\r\n    }\r\n  }\r\n\r\n  createTables() {\r\n    // Users table\r\n    this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS users (\r\n        id TEXT PRIMARY KEY,\r\n        email TEXT UNIQUE NOT NULL,\r\n        password TEXT NOT NULL,\r\n        name TEXT NOT NULL,\r\n        role TEXT NOT NULL CHECK (role IN ('admin', 'user')),\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )\r\n    `);\r\n\r\n    // Forms table\r\n    this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS forms (\r\n        id TEXT PRIMARY KEY,\r\n        title TEXT NOT NULL,\r\n        description TEXT,\r\n        fields TEXT NOT NULL,\r\n        is_active BOOLEAN DEFAULT 1,\r\n        created_by TEXT NOT NULL,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (created_by) REFERENCES users (id)\r\n      )\r\n    `);\r\n\r\n    // Form responses table\r\n    this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS form_responses (\r\n        id TEXT PRIMARY KEY,\r\n        form_id TEXT NOT NULL,\r\n        user_id TEXT NOT NULL,\r\n        data TEXT NOT NULL,\r\n        submitted_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (form_id) REFERENCES forms (id) ON DELETE CASCADE,\r\n        FOREIGN KEY (user_id) REFERENCES users (id),\r\n        UNIQUE(form_id, user_id)\r\n      )\r\n    `);\r\n\r\n    // Create indexes for better performance\r\n    this.db.exec(`\r\n      CREATE INDEX IF NOT EXISTS idx_forms_created_by ON forms(created_by);\r\n      CREATE INDEX IF NOT EXISTS idx_responses_form_id ON form_responses(form_id);\r\n      CREATE INDEX IF NOT EXISTS idx_responses_user_id ON form_responses(user_id);\r\n    `);\r\n  }\r\n\r\n  async seedInitialData() {\r\n    try {\r\n      // Check if admin user already exists\r\n      const adminExists = this.db.prepare('SELECT id FROM users WHERE email = ?').get('admin@example.com');\r\n      \r\n      if (!adminExists) {\r\n        // Create admin user\r\n        const adminPassword = await bcrypt.hash('admin123', 10);\r\n        this.db.prepare(`\r\n          INSERT INTO users (id, email, password, name, role)\r\n          VALUES (?, ?, ?, ?, ?)\r\n        `).run(uuidv4(), 'admin@example.com', adminPassword, 'Admin User', 'admin');\r\n\r\n        // Create demo user\r\n        const userPassword = await bcrypt.hash('user123', 10);\r\n        this.db.prepare(`\r\n          INSERT INTO users (id, email, password, name, role)\r\n          VALUES (?, ?, ?, ?, ?)\r\n        `).run(uuidv4(), 'user@example.com', userPassword, 'Regular User', 'user');\r\n\r\n        // Create another demo user\r\n        this.db.prepare(`\r\n          INSERT INTO users (id, email, password, name, role)\r\n          VALUES (?, ?, ?, ?, ?)\r\n        `).run(uuidv4(), 'user2@example.com', userPassword, 'Another User', 'user');\r\n\r\n        console.log('Initial data seeded successfully');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error seeding initial data:', error);\r\n    }\r\n  }\r\n\r\n  // User operations\r\n  async createUser(email, password, name, role = 'user') {\r\n    try {\r\n      const hashedPassword = await bcrypt.hash(password, 10);\r\n      const userId = uuidv4();\r\n      \r\n      this.db.prepare(`\r\n        INSERT INTO users (id, email, password, name, role)\r\n        VALUES (?, ?, ?, ?, ?)\r\n      `).run(userId, email, hashedPassword, name, role);\r\n\r\n      return { success: true, userId };\r\n    } catch (error) {\r\n      if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\r\n        throw new Error('User already exists');\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async authenticateUser(email, password) {\r\n    try {\r\n      const user = this.db.prepare('SELECT * FROM users WHERE email = ?').get(email);\r\n      \r\n      if (!user) {\r\n        return null;\r\n      }\r\n\r\n      const isValidPassword = await bcrypt.compare(password, user.password);\r\n      \r\n      if (!isValidPassword) {\r\n        return null;\r\n      }\r\n\r\n      const { password: _, ...userWithoutPassword } = user;\r\n      return userWithoutPassword;\r\n    } catch (error) {\r\n      console.error('Authentication error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getUserById(userId) {\r\n    try {\r\n      const user = this.db.prepare('SELECT id, email, name, role, created_at FROM users WHERE id = ?').get(userId);\r\n      return user || null;\r\n    } catch (error) {\r\n      console.error('Get user error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getAllUsers() {\r\n    try {\r\n      return this.db.prepare('SELECT id, email, name, role, created_at FROM users ORDER BY created_at DESC').all();\r\n    } catch (error) {\r\n      console.error('Get all users error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Form operations\r\n  async createForm(formData, createdBy) {\r\n    try {\r\n      const formId = uuidv4();\r\n      const fieldsJson = JSON.stringify(formData.fields);\r\n      \r\n      this.db.prepare(`\r\n        INSERT INTO forms (id, title, description, fields, created_by)\r\n        VALUES (?, ?, ?, ?, ?)\r\n      `).run(formId, formData.title, formData.description, fieldsJson, createdBy);\r\n\r\n      return { success: true, formId };\r\n    } catch (error) {\r\n      console.error('Create form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateForm(formId, formData) {\r\n    try {\r\n      const fieldsJson = JSON.stringify(formData.fields);\r\n      \r\n      this.db.prepare(`\r\n        UPDATE forms \r\n        SET title = ?, description = ?, fields = ?, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `).run(formData.title, formData.description, fieldsJson, formId);\r\n\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Update form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteForm(formId) {\r\n    try {\r\n      this.db.prepare('DELETE FROM forms WHERE id = ?').run(formId);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Delete form error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getFormById(formId) {\r\n    try {\r\n      const form = this.db.prepare('SELECT * FROM forms WHERE id = ?').get(formId);\r\n      \r\n      if (form) {\r\n        return {\r\n          ...form,\r\n          fields: JSON.parse(form.fields)\r\n        };\r\n      }\r\n      \r\n      return null;\r\n    } catch (error) {\r\n      console.error('Get form error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getAllForms() {\r\n    try {\r\n      const forms = this.db.prepare('SELECT * FROM forms ORDER BY created_at DESC').all();\r\n      \r\n      return forms.map(form => ({\r\n        ...form,\r\n        fields: JSON.parse(form.fields)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Get all forms error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getActiveForms() {\r\n    try {\r\n      const forms = this.db.prepare('SELECT * FROM forms WHERE is_active = 1 ORDER BY created_at DESC').all();\r\n      \r\n      return forms.map(form => ({\r\n        ...form,\r\n        fields: JSON.parse(form.fields)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Get active forms error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Response operations\r\n  async submitResponse(formId, userId, responseData) {\r\n    try {\r\n      const responseId = uuidv4();\r\n      const dataJson = JSON.stringify(responseData);\r\n      \r\n      this.db.prepare(`\r\n        INSERT INTO form_responses (id, form_id, user_id, data)\r\n        VALUES (?, ?, ?, ?)\r\n      `).run(responseId, formId, userId, dataJson);\r\n\r\n      return { success: true, responseId };\r\n    } catch (error) {\r\n      if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\r\n        throw new Error('You have already responded to this form');\r\n      }\r\n      console.error('Submit response error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getFormResponses(formId) {\r\n    try {\r\n      const responses = this.db.prepare(`\r\n        SELECT fr.*, u.name as user_name, u.email as user_email\r\n        FROM form_responses fr\r\n        JOIN users u ON fr.user_id = u.id\r\n        WHERE fr.form_id = ?\r\n        ORDER BY fr.submitted_at DESC\r\n      `).all(formId);\r\n      \r\n      return responses.map(response => ({\r\n        ...response,\r\n        data: JSON.parse(response.data)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Get form responses error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getUserResponses(userId) {\r\n    try {\r\n      const responses = this.db.prepare(`\r\n        SELECT fr.*, f.title as form_title\r\n        FROM form_responses fr\r\n        JOIN forms f ON fr.form_id = f.id\r\n        WHERE fr.user_id = ?\r\n        ORDER BY fr.submitted_at DESC\r\n      `).all(userId);\r\n      \r\n      return responses.map(response => ({\r\n        ...response,\r\n        data: JSON.parse(response.data)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Get user responses error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async hasUserResponded(formId, userId) {\r\n    try {\r\n      const response = this.db.prepare(`\r\n        SELECT id FROM form_responses \r\n        WHERE form_id = ? AND user_id = ?\r\n      `).get(formId, userId);\r\n      \r\n      return !!response;\r\n    } catch (error) {\r\n      console.error('Check user response error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getFormResponseCount(formId) {\r\n    try {\r\n      const result = this.db.prepare(`\r\n        SELECT COUNT(*) as count \r\n        FROM form_responses \r\n        WHERE form_id = ?\r\n      `).get(formId);\r\n      \r\n      return result.count;\r\n    } catch (error) {\r\n      console.error('Get response count error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Statistics\r\n  async getStatistics() {\r\n    try {\r\n      const stats = {\r\n        totalUsers: this.db.prepare('SELECT COUNT(*) as count FROM users').get().count,\r\n        totalForms: this.db.prepare('SELECT COUNT(*) as count FROM forms').get().count,\r\n        totalResponses: this.db.prepare('SELECT COUNT(*) as count FROM form_responses').get().count,\r\n        activeForms: this.db.prepare('SELECT COUNT(*) as count FROM forms WHERE is_active = 1').get().count\r\n      };\r\n      \r\n      return stats;\r\n    } catch (error) {\r\n      console.error('Get statistics error:', error);\r\n      return { totalUsers: 0, totalForms: 0, totalResponses: 0, activeForms: 0 };\r\n    }\r\n  }\r\n\r\n  // Close database connection\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n    }\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nconst databaseService = new DatabaseService();\r\n\r\nexport default databaseService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}