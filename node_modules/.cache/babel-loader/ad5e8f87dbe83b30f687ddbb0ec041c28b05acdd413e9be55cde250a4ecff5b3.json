{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst {\n  promisify\n} = require('util');\nconst {\n  cppdb\n} = require('../util');\nconst fsAccess = promisify(fs.access);\nmodule.exports = async function backup(filename, options) {\n  if (options == null) options = {};\n\n  // Validate arguments\n  if (typeof filename !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n\n  // Interpret options\n  filename = filename.trim();\n  const attachedName = 'attached' in options ? options.attached : 'main';\n  const handler = 'progress' in options ? options.progress : null;\n\n  // Validate interpreted options\n  if (!filename) throw new TypeError('Backup filename cannot be an empty string');\n  if (filename === ':memory:') throw new TypeError('Invalid backup filename \":memory:\"');\n  if (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n  if (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n  if (handler != null && typeof handler !== 'function') throw new TypeError('Expected the \"progress\" option to be a function');\n\n  // Make sure the specified directory exists\n  await fsAccess(path.dirname(filename)).catch(() => {\n    throw new TypeError('Cannot save backup because the directory does not exist');\n  });\n  const isNewFile = await fsAccess(filename).then(() => false, () => true);\n  return runBackup(this[cppdb].backup(this, attachedName, filename, isNewFile), handler || null);\n};\nconst runBackup = (backup, handler) => {\n  let rate = 0;\n  let useDefault = true;\n  return new Promise((resolve, reject) => {\n    setImmediate(function step() {\n      try {\n        const progress = backup.transfer(rate);\n        if (!progress.remainingPages) {\n          backup.close();\n          resolve(progress);\n          return;\n        }\n        if (useDefault) {\n          useDefault = false;\n          rate = 100;\n        }\n        if (handler) {\n          const ret = handler(progress);\n          if (ret !== undefined) {\n            if (typeof ret === 'number' && ret === ret) rate = Math.max(0, Math.min(0x7fffffff, Math.round(ret)));else throw new TypeError('Expected progress callback to return a number or undefined');\n          }\n        }\n        setImmediate(step);\n      } catch (err) {\n        backup.close();\n        reject(err);\n      }\n    });\n  });\n};","map":{"version":3,"names":["fs","require","path","promisify","cppdb","fsAccess","access","module","exports","backup","filename","options","TypeError","trim","attachedName","attached","handler","progress","dirname","catch","isNewFile","then","runBackup","rate","useDefault","Promise","resolve","reject","setImmediate","step","transfer","remainingPages","close","ret","undefined","Math","max","min","round","err"],"sources":["C:/Users/Highcastle/Documents/Cidadão+ Consulta Pública/node_modules/better-sqlite3/lib/methods/backup.js"],"sourcesContent":["'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { cppdb } = require('../util');\nconst fsAccess = promisify(fs.access);\n\nmodule.exports = async function backup(filename, options) {\n\tif (options == null) options = {};\n\n\t// Validate arguments\n\tif (typeof filename !== 'string') throw new TypeError('Expected first argument to be a string');\n\tif (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n\n\t// Interpret options\n\tfilename = filename.trim();\n\tconst attachedName = 'attached' in options ? options.attached : 'main';\n\tconst handler = 'progress' in options ? options.progress : null;\n\n\t// Validate interpreted options\n\tif (!filename) throw new TypeError('Backup filename cannot be an empty string');\n\tif (filename === ':memory:') throw new TypeError('Invalid backup filename \":memory:\"');\n\tif (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n\tif (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n\tif (handler != null && typeof handler !== 'function') throw new TypeError('Expected the \"progress\" option to be a function');\n\n\t// Make sure the specified directory exists\n\tawait fsAccess(path.dirname(filename)).catch(() => {\n\t\tthrow new TypeError('Cannot save backup because the directory does not exist');\n\t});\n\n\tconst isNewFile = await fsAccess(filename).then(() => false, () => true);\n\treturn runBackup(this[cppdb].backup(this, attachedName, filename, isNewFile), handler || null);\n};\n\nconst runBackup = (backup, handler) => {\n\tlet rate = 0;\n\tlet useDefault = true;\n\n\treturn new Promise((resolve, reject) => {\n\t\tsetImmediate(function step() {\n\t\t\ttry {\n\t\t\t\tconst progress = backup.transfer(rate);\n\t\t\t\tif (!progress.remainingPages) {\n\t\t\t\t\tbackup.close();\n\t\t\t\t\tresolve(progress);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (useDefault) {\n\t\t\t\t\tuseDefault = false;\n\t\t\t\t\trate = 100;\n\t\t\t\t}\n\t\t\t\tif (handler) {\n\t\t\t\t\tconst ret = handler(progress);\n\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\tif (typeof ret === 'number' && ret === ret) rate = Math.max(0, Math.min(0x7fffffff, Math.round(ret)));\n\t\t\t\t\t\telse throw new TypeError('Expected progress callback to return a number or undefined');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetImmediate(step);\n\t\t\t} catch (err) {\n\t\t\t\tbackup.close();\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t});\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}